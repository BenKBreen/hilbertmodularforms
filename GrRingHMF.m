load "config.m";

// Helper Functions a
PW := function(k,degree)
  return [k:i in [1..degree]];
end function;

// Return the smallest weight k such that the space of parallel weight k-forms
// hase nonzero dimension
SmallestWeight := function(F, N, M, prec, MaxWeight) 
  // TODO IMPLEMENT THIS FUNCTION
  return 2;
end function;

// Return the appropriate matrix precision to use
MatrixPrecision := function(N, weight :Buffer := 12)
  // TODO IMPLEMENT THIS FUNCTION
  return 40;
end function;

// Given a matrix of row vectors, finds linear relations amongst the rows
// Input := matrix = any matrix
// Output := a list of all relations amongst rows of matrix
FindRelations := function(matrix)
  kernelOfMatrix := Kernel(matrix);
relations := [Eltseq(v) : v in Basis(kernelOfMatrix)];
return relations;
end function;

// Given a list of generators and their weights, finds all weighted monomials of weight k
// Input: GenList = a list of generators
// Input: GenWeights = the weights of the generators
// Input: k = the weight you want monomials in
// Output: both the evaluated monomials, so a list of modular forms, and the formal monomials
ProduceMonomials := function(GenList,GenWeights, k)
  R<[x]> := PolynomialRing(Rationals(),GenWeights);
FormalMonomials := MonomialsOfWeightedDegree(R,k);

// Now evaluate these monomials at the generators
EvalMonomials := [];
for j := 1 to #FormalMonomials do
	 Exp := Exponents(FormalMonomials[j]);
CurrMonomial := 1;
for k := 1 to #GenList do
                        if Exp[k] ne 0 then
  CurrMonomial := CurrMonomial * GenList[k]^Exp[k];
end if;
end for;
EvalMonomials[j] := CurrMonomial;
end for;
return EvalMonomials,FormalMonomials;
end function;


// Given monomials and a number of relations amongst them, computes the rest of a basis
// of ModularForms(N,k)
// Input: N = level
// Input: k = weight
// Input: EvaluatedMonomials = list of ModularForms, generated by weighted monomials of generators
// Input: NumberOfRelations = the total number of relations amongst those monomials
// Output: a list of modular forms, one corresponding to each new generator
FindNewGenerators := function(N,k,EvaluatedMonomials,NumberOfRelations, inputBasis,prec,M)


V := VectorSpace(Rationals(),23);

CurrentWeightBasis := inputBasis;
CurrentWeightVectorBasis := [Coefficients(CurrentWeightBasis[i]):i in [1..#CurrentWeightBasis]];

VectorEvaluatedMonomials := [Coefficients(EvaluatedMonomials[i]):i in [1..#EvaluatedMonomials]];

MonomialSubspace := sub<V|VectorEvaluatedMonomials>;
// The below is the same as Dimension(MonomialSubspace) but cheaper computationally
numLinIndMonomials := #EvaluatedMonomials - NumberOfRelations;

CurrentWeightSubspace := sub<V|CurrentWeightVectorBasis>;
ExtendedMonomialBasis := ExtendBasis(MonomialSubspace,CurrentWeightSubspace);
NewGeneratorsVec := [ExtendedMonomialBasis[i]:i in [numLinIndMonomials+1..#ExtendedMonomialBasis]];
NewGens := [];
for i := 1 to #NewGeneratorsVec do 
	   Append(~NewGens,HMF(M,PW(k,2),Eltseq(NewGeneratorsVec[i])));
	   end for;

		  //NewGens := NewGeneratorsVectorsToForms(NewGeneratorsVec,N,k,CurrentWeightBasis);
return NewGens;
end function;


// One of two main control functions
// Input: N=level
// Input: MaxWeight = highest weight to check for relations in
// Output: Associative array of generators in each weight, those generators in a list,
//              the weights of the generators, a list of relations and list of what weight those relations are in
ConstructGeneratorsAndRelations := function(F,N,M,prec,MaxWeight)
  Gens := AssociativeArray();
GenWeights := [];
GenList := [* *];
Rels := [];
RelWeights := [];
X := HeckeCharacterGroup(N);
triv := X!1;
eta := triv;
psi := triv;

LowestWeight := SmallestWeight(F,N,M,prec,MaxWeight);
a,b := CuspFormBasis(M,PW(LowestWeight,Degree(F)));
FirstGenerators := a cat [EisensteinSeries(M,eta,psi,PW(LowestWeight,Degree(F)))];
//Basis(BaseExtend(ModularForms(N, LowestWeight),Rationals()));
Gens[LowestWeight] := FirstGenerators;
GenWeights := GenWeights cat [LowestWeight : i in [1..#FirstGenerators]];

for i := (LowestWeight div 2 + 1) to (MaxWeight div 2) do
	 k := 2*i;
"Current weight: ", k;
a,b:=CuspFormBasis(M,PW(k,2));

currWeightBasis := a cat [EisensteinSeries(M,eta,psi,PW(k,2))];
Gens[k] := [];
GenList := GenList cat [* f : f in Gens[k - 2]*];

// WRONG LINE ERASE
//if k eq 8 then return GenList;end if;

EvaluatedMonomials := ProduceMonomials(GenList, GenWeights, k);


NumNewRelations := 0;
                if #EvaluatedMonomials ne 0 then
		prec := MatrixPrecision(N,k);
matCombos := Matrix([Coefficients(EvaluatedMonomials[i]):i in [1..#EvaluatedMonomials]]);
NewRelations := FindRelations(matCombos);
Rels := Rels cat NewRelations;
RelWeights := RelWeights cat [k : i in [1..#NewRelations]];
NumNewRelations := #NewRelations;
end if;
if k le (MaxWeight) then
NewGensModForms := FindNewGenerators(N, k, EvaluatedMonomials, NumNewRelations,currWeightBasis,prec,M);
Gens[k] := NewGensModForms;
GenWeights := GenWeights cat [k : i in [1..#NewGensModForms]];

end if;
end for;

return Gens,GenList,GenWeights,Rels,RelWeights;
end function;

// Input: Rels = relations amongst monomials
// Input: RelWeights = what weight those relations are in
// Input: GradedRing = a graded ring that includes the weights of the relations
// Output: polynomials in the graded ring representing the relations
MakePolyList := function(Rels,RelWeights,GradedRing)
  PolynomialList := [];
for i := 1 to #Rels do
	 CurrentRelationWeight := RelWeights[i];
CurrentRelation := Rels[i];
Monomials := MonomialsOfWeightedDegree(GradedRing,CurrentRelationWeight);
CurrentRelationPolynomial := 0;
for j := 1 to #CurrentRelation do
	 CurrentRelationPolynomial := CurrentRelationPolynomial + Monomials[j]*CurrentRelation[j];
end for;
Append(~PolynomialList,CurrentRelationPolynomial);
end for;
return PolynomialList;
end function;

// The other main control function. Turns the work of ConstructGeneratorsAndRelations into our
// quotient ring
// Input: most of the output of ConstructGeneratorsAndRelations, N=level
// Output: R = polynomial ring with weighted generators
// Output: I = ideal generated by relations in R
// Output: R/I
ConstructRingAndIdeal := function(GenWeights,Rels,RelWeights,N)
  R := PolynomialRing(Rationals(),GenWeights);
PolynomialList := MakePolyList(Rels,RelWeights,R);

I := ideal<R | PolynomialList>;
MGamma := quo<R | I>;

return R, I, MGamma;
end function;

CanonicalRing := function(F,N,M,prec : MaxWeight := 20)
  //THIS IS WRONG ERASE IT
  //genList := ConstructGeneratorsAndRelations(F,N,M,prec,MaxWeight);
  //return genList;
    gens,genList,genWeights,rels,relWeights := ConstructGeneratorsAndRelations(F,N,M,prec,MaxWeight);
R,I,MGamma := ConstructRingAndIdeal(genWeights,rels,relWeights,N);

return R,I,MGamma, quo<R | I>,genList,genWeights;
end function;


// Example call
F<nu> := QuadraticField(5);
ZF := Integers(F);
N := ideal<ZF|[1]>;
prec := 50;
M := HMFSpace(F, N, prec);
