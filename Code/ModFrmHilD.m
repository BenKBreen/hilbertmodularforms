/*****
ModFrmHilD
*****/

////////// ModFrmHilD attributes //////////

declare type ModFrmHilD [ModFrmHilDElt];
declare attributes ModFrmHilD:
  Field, // FldNum : totally real field
  Integers, // RngOrd : ZF
  Level, // RngOrdIdl : ideal of Integers(Field)
  Precision, // RngIntElt : precision for all expansions with this parent
  Ideals, // SeqEnum[RngOrdIdl]
  Dictionary, // Assoc maps Ideals[i] to i
  MultiplicationTable, // SeqEnum[pairs of integers] TODO
  Representatives, // SeqEnum[nu] TODO
  DictionaryRepresentatives; // Assoc maps Representatives[i] to i TODO

////////// ModFrmHilD fundamental intrinsics //////////

intrinsic Print(M::ModFrmHilD)
  {}
  printf "Space of Hilbert modular forms over %o.\n", M`Field;
  printf "Precision: %o\n", M`Precision;
  printf "Level: (Norm, Ideal) = (%o, %o)\n", Norm(M`Level),  Generators(M`Level);
end intrinsic;

intrinsic 'in'(f::., M::ModFrmHilD) -> BoolElt
  {}
  if Type(f) ne ModFrmHilDElt then
    return false, "The first argument should be a ModFrmHilDElt";
  else
    return Parent(f) eq M;
  end if;
end intrinsic;

intrinsic 'eq'(M1::ModFrmHilD, M2::ModFrmHilD) -> BoolElt
  {True iff the two spaces of Hilbert modular forms are identically the same}
  return IsIdentical(M1, M2);
end intrinsic;

// TODO see classical case /Applications/Magma/package/Geometry/ModFrm/creation.m
intrinsic IsCoercible(M::ModFrmHilD, f::.) -> BoolElt, .
  {}
  if Type(f) eq ModFrmHilDElt and Parent(f) eq M then
    return true, f;
  end if;
  return false;
end intrinsic;

////////// ModFrmHilD access to attributes //////////

intrinsic BaseField(M::ModFrmHilD) -> FldAlg
  {The base field of the space M of Hilbert modular forms.}
  return M`Field;
end intrinsic;

intrinsic Integers(M::ModFrmHilD) -> RngOrd
  {}
  return M`Integers;
end intrinsic;

intrinsic Level(M::ModFrmHilD) -> RngOrdIdl
  {The level of the space M of Hilbert modular forms.}
  return M`Level;
end intrinsic;

intrinsic Precision(M::ModFrmHilD) -> RngIntElt
  {The Precision of the space M of Hilbert modular forms.}
  return M`Precision;
end intrinsic;

intrinsic Ideals(M::ModFrmHilD) -> SeqEnum[RngOrdIdl]
  {The Ideals of the space M of Hilbert modular forms.}
  return M`Ideals;
end intrinsic;

intrinsic Dictionary(M::ModFrmHilD) -> Assoc
  {The dictionary for ideals of the space M of Hilbert modular forms.}
  return M`Dictionary;
end intrinsic;

// TODO add text
intrinsic MultiplicationTable(M::ModFrmHilD) -> SeqEnum
  {}
  return M`MultiplicationTable;
end intrinsic;

// TODO add text
intrinsic DictionaryRepresentatives(M::ModFrmHilD) -> Assoc
  {}
  return M`DictionaryRepresentatives;
end intrinsic;

// TODO add text
intrinsic Representatives(M::ModFrmHilD) -> SeqEnum
  {}
  return M`Representatives;
end intrinsic;

////////// ModFrmHilD creation functions //////////

intrinsic ModFrmHilDInitialize() -> ModFrmHilD
  {Create an empty ModFrmHilD object.}
  M := New(ModFrmHilD);
  return M;
end intrinsic;

intrinsic HMFSpace(F::FldNum, N::RngOrdIdl, prec::RngIntElt) -> ModFrmHilD
  {Generates the space ModFrmHilD over F with level N.}
  assert IsTotallyReal(F);
  assert NumberField(Order(N)) eq F;
  M := ModFrmHilDInitialize();
  // field
  M`Field := F;
  // level
  M`Level := N;
  // prec
  M`Precision := prec;
  // ideals
  zero_ideal := ideal<Integers(F)|0>;
  Is := [zero_ideal] cat IdealsUpTo(prec, F);
  M`Ideals := Is;
  dictionary := AssociativeArray();
  for i := 1 to #Is do
    dictionary[Is[i]] := i;
  end for;
  M`Dictionary := dictionary;
  return M;
end intrinsic;

intrinsic ModFrmHilDCopy(M::ModFrmHilD) -> ModFrmHilD
  {new instance of ModFrmHilD.}
  M1 := ModFrmHilDInitialize();
  for attr in GetAttributes(Type(M)) do
    if assigned M``attr then
      M1``attr := M``attr;
    end if;
  end for;
  return M1;
end intrinsic;

intrinsic GetIndices(M::ModFrmHilD) -> List
  {returns list of [nu, [[nu1,nu2],...] ] up to precision.}
  // TODO 144 in HilbertMult.m
end intrinsic;

intrinsic GetPosition(M::ModFrmHilD, nu::RngOrdElt) -> RngIntElt
  {returns the position of ideal generated by nu.}
  if assigned M`DictionaryRepresentatives then
    return M`DictionaryRepresentatives[nu];
  else
    ZF := Integers(BaseField(M));
    assert Order(nu) eq ZF;
    I_nu := ideal< ZF | nu >;
    assert Norm(I_nu) le Precision(M);
    return Dictionary(M)[I_nu];
  end if;
end intrinsic;

intrinsic GetPosition(M::ModFrmHilD, I::RngOrdIdl) -> RngIntElt
  {returns the position of ideal.}
  return Dictionary(M)[I];
end intrinsic;

intrinsic HMFEquipWithMultiplication(M::ModFrmHilD) -> ModFrmHilD
  {Assign representatives and a dictionary for it to M.}
  indices := GetIndices(M);
  reps := [elt[1] : elt in indices];
  reps_indexed := [ 0 : i in [1..#reps] ];
  dict_reps := AssociativeArray();
  for nu in reps do
    dict_reps[nu] := GetPosition(M, nu);
  end for;
  mult_table := [[] : nu in reps];
  for i := 1 to #indices do
    nu_i := indices[i][1];
    pairs_i := indices[i][2];
    list_i := [[dict_reps[elt[1]], dict_reps[elt[2]]] : elt in pairs_i];
    mult_table[dict_reps[nu_i]] := list_i;
    reps_indexed[dict_reps[nu_i]] := nu_i;
    // assert nu_i eq ShintaniGenerator(M, Ideals(M)[i]);
  end for;
  M`Representatives := reps_indexed;
  M`MultiplicationTable := mult_table;
  M`DictionaryRepresentatives := dict_reps;
  return M;
end intrinsic;
